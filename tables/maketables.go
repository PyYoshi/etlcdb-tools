// +build ignore

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	gofmt "go/format"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
)

const jisx0208TxtURL = "http://ftp.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/JIS/JIS0208.TXT"

func init() {
	flag.StringVar(&outPath, "out", "", "e.g) ./locales_generated.go")
}

var (
	outPath string
)

type generator struct {
	buf bytes.Buffer
}

func (g *generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *generator) Println(a ...interface{}) {
	fmt.Fprintln(&g.buf, a...)
}

func (g *generator) Format() []byte {
	src, err := gofmt.Source(g.buf.Bytes())
	if err != nil {
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func parseJisX0208() (map[uint16]uint16, error) {
	res, err := http.Get(jisx0208TxtURL)
	if err != nil {
		log.Fatalf("%q: Get: %v", jisx0208TxtURL, err)
	}
	defer res.Body.Close()

	scanner := bufio.NewScanner(res.Body)
	mapping := map[uint16]uint16{}
	for scanner.Scan() {
		s := strings.TrimSpace(scanner.Text())
		if s == "" || s[0] == '#' {
			continue
		}

		x, y, z := uint16(0), uint16(0), uint16(0)
		if _, err := fmt.Sscanf(s, "0x%x\t0x%x\t0x%x", &x, &y, &z); err != nil {
			return map[uint16]uint16{}, fmt.Errorf("%q: could not parse %q", jisx0208TxtURL, s)
		}

		mapping[y] = z
	}
	if err := scanner.Err(); err != nil {
		return map[uint16]uint16{}, fmt.Errorf("%q: scanner error: %v", jisx0208TxtURL, err)
	}

	return mapping, nil
}

func main() {
	flag.Parse()
	if outPath == "" {
		flag.Usage()
		os.Exit(1)
		return
	}

	var g generator

	g.Printf("// generated by go run maketables.go %s; DO NOT EDIT\n\n", strings.Join(os.Args[1:], " "))
	g.Printf("package tables \n\n")

	mappingJisX0208, err := parseJisX0208()
	if err != nil {
		log.Fatal(err)
	}

	g.Println("var jisx0208 = map[uint16]uint16{")
	for j, u := range mappingJisX0208 {
		if u != 0 {
			g.Printf("\t0x%04x: 0x%04x, // %s\n", j, u, string(u))
		}
	}
	g.Printf("}\n\n")

	dst := g.Format()
	err = ioutil.WriteFile(outPath, dst, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}
